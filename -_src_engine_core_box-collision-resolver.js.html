<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Home: Source - ./src/engine/core/box-collision-resolver.js</title>
    <script src="static/classy.js"></script>
    <script src="static/highlight/highlight.min.js"></script>
    <script src="static/highlight/langs/javascript.min.js"></script>
    <script src="static/highlight/langs/json.min.js"></script>
    <link type="text/css" rel="stylesheet" href="static/highlight/highlight.min.css">
    <link type="text/css" rel="stylesheet" href="static/classy.css">
</head>

<body>
    <header class="page-header">
        <h1 class="package-details">
            <a class="package-name" href="./">
                
                <span>Home</span>
            </a>
            
        </h1>
        <h2 class="page-title">Source: <span class="ancestors"></span>./src/engine/core/box-collision-resolver.js</h2>
        <div class="page-links">
            
            <div class="page-nav-toggle tiny-page-nav-toggle">
                <input type="checkbox" name="tiny-page-nav-toggle" id="tiny-page-nav-toggle" autocomplete="off"/>
                <label for="tiny-page-nav-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </label>
            </div>
        </div>
    </header>
    <nav class="page-nav">
        <label class="hidden" for="tiny-page-nav"></label>
        <input class="hidden tiny-page-nav-target" type="checkbox" id="tiny-page-nav" autocomplete="off"/>
        <div class="nav-content">
            <h3>Classes</h3><ul><li><a href="BoxCollisionResolver.html">BoxCollisionResolver</a></li><li><a href="CircleCollisionResolver.html">CircleCollisionResolver</a></li><li><a href="Circle.html">Circle</a></li><li><a href="CollisionResolver.html">CollisionResolver</a></li><li><a href="DestroyManager.html">DestroyManager</a></li><li><a href="GameObject.html">GameObject</a></li><li><a href="HTMLManager.html">HTMLManager</a></li><li><a href="InputManager.html">InputManager</a></li><li><a href="LayerManager.html">LayerManager</a></li><li><a href="PhysicsManager.html">PhysicsManager</a></li><li><a href="Rect.html">Rect</a></li><li><a href="RenderManager.html">RenderManager</a></li><li><a href="ResourceLoaderFactory.html">ResourceLoaderFactory</a></li><li><a href="ResourceLoader.html">ResourceLoader</a></li><li><a href="AudioResourceLoader.html">AudioResourceLoader</a></li><li><a href="ImageResourceLoader.html">ImageResourceLoader</a></li><li><a href="ResourceManager.html">ResourceManager</a></li><li><a href="SceneManager.html">SceneManager</a></li><li><a href="Sprite.html">Sprite</a></li><li><a href="Text.html">Text</a></li><li><a href="Collider.html">Collider</a></li><li><a href="BoxCollider.html">BoxCollider</a></li><li><a href="CircleCollider.html">CircleCollider</a></li><li><a href="Color.html">Color</a></li><li><a href="Layer.html">Layer</a></li><li><a href="DefaultLayer.html">DefaultLayer</a></li><li><a href="TerrainLayer.html">TerrainLayer</a></li><li><a href="UnitLayer.html">UnitLayer</a></li><li><a href="Manifold.html">Manifold</a></li><li><a href="Matrix.html">Matrix</a></li><li><a href="RigidBody.html">RigidBody</a></li><li><a href="Transform.html">Transform</a></li><li><a href="Vector.html">Vector</a></li><li><a href="Engine.html">Engine</a></li><li><a href="Particle.html">Particle</a></li><li><a href="ParticleEffect.html">ParticleEffect</a></li><li><a href="SoundEffect.html">SoundEffect</a></li><li><a href="Path.html">Path</a></li><li><a href="Timer.html">Timer</a></li></ul><h3>Globals</h3><ul><li><a href="global.html#KEY_STATUS">KEY_STATUS</a></li><li><a href="global.html#makeForm">makeForm</a></li><li><a href="global.html#getAvailableFpsAndResolution">getAvailableFpsAndResolution</a></li><li><a href="global.html#getAvailableResolution">getAvailableResolution</a></li><li><a href="global.html#getAvailableFpsList">getAvailableFpsList</a></li><li><a href="global.html#getCurrentFps">getCurrentFps</a></li><li><a href="global.html#typeCheck">typeCheck</a></li><li><a href="global.html#typeCheckAndClamp">typeCheckAndClamp</a></li><li><a href="global.html#findKeyInObjectWithValue">findKeyInObjectWithValue</a></li><li><a href="global.html#writeErrorMessageOnDocument">writeErrorMessageOnDocument</a></li></ul>
        </div>
    </nav>
    <main id="main">
        <article class="content-container source-code">
    <header class="section-header">
        <h2 class="page-title subsection-title">Source: <span class="ancestors"></span>./src/engine/core/box-collision-resolver.js</h2>
    </header>
    <pre class="prettyprint source linenums"><code>import Manifold from "/src/engine/data-structure/manifold.js";
import Vector from "/src/engine/data-structure/vector.js";

import CollisionResolver from "/src/engine/core/collision-resolver.js";

import { clamp } from "/src/engine/utils.js";

/**
 * 상자와 상자 또는 상자와 원 사이의 충돌체크 및
 * 충돌깊이와 반작용방향을 연산하는 책임을 맡는다.
 *
 * @extends CollisionResolver
 */
class BoxCollisionResolver extends CollisionResolver {
  /**
   * 주 객체를 등록하여 충돌체크를 진행한다.
   *
   * @param {GameObject} box
   */
  constructor(box) {
    super(box);
    this.box = box;
  }

  /**
   * 상자와 상자가 충돌했다면 true를 반환한다.
   *
   * @param {GameObject} box - 이 객체와 충돌인지 확인할 객체
   * @returns {boolean}
   */
  isCollideWithBox(box) {
    // 단순하게 AABB충돌체크 방식을 사용한다.
    if (
      this.box.getColliderWorldPosition().x -
        this.box.getWorldBoundary().x / 2 >
        box.getColliderWorldPosition().x + box.getWorldBoundary().x / 2 ||
      this.box.getColliderWorldPosition().x +
        this.box.getWorldBoundary().x / 2 &lt;
        box.getColliderWorldPosition().x - box.getWorldBoundary().x / 2 ||
      this.box.getColliderWorldPosition().y -
        this.box.getWorldBoundary().y / 2 >
        box.getColliderWorldPosition().y + box.getWorldBoundary().y / 2 ||
      this.box.getColliderWorldPosition().y +
        this.box.getWorldBoundary().y / 2 &lt;
        box.getColliderWorldPosition().y - box.getWorldBoundary().y / 2
    ) {
      return false;
    }
    return true;
  }

  /**
   * 상자와 원이 충돌했다면 true를 반환한다.
   *
   * @param {GameObject} circle - 이 객체와 충돌인지 확인할 객체
   * @returns {boolean}
   */
  isCollideWithCircle(circle) {
    // 원의 중심과 상자의 중심간 거리의 차를 구한다.
    const distance = circle
      .getColliderWorldPosition()
      .minus(this.box.getColliderWorldPosition());

    distance.x = Math.abs(distance.x);
    distance.y = Math.abs(distance.y);

    // 중심간 차의 절대값이 상자의 주변에 원이 접했을 때의 거리보다 크다면
    // 충돌하지 않은 것이다.
    if (
      distance.x >
        this.box.getWorldBoundary().x / 2 + circle.getWorldBoundary() ||
      distance.y > this.box.getWorldBoundary().y / 2 + circle.getWorldBoundary()
    ) {
      return false;
    }

    // 중심간 차의 절대값이 상자의 크기의 절반보다 작다면
    // 원이 상자 안에 있는 셈이므로 충돌한 것이다.
    if (
      distance.x &lt;= this.box.getWorldBoundary().x / 2 ||
      distance.y &lt;= this.box.getWorldBoundary().y / 2
    ) {
      return true;
    }

    // 꼭짓점부분에서 충돌이 될 가능성을 검사한다.
    const d = distance.minus(this.box.getWorldBoundary().multiply(0.5));
    return (
      d.squareLength() &lt;= circle.getWorldBoundary() * circle.getWorldBoundary()
    );
  }

  /**
   * 상자와 상자가 충돌했을 때 충돌깊이와 반작용방향을 반환한다.
   *
   *               +-------+
   *     +-----+   |       |
   *     |  x  |   |   x   |
   *     +-----+   |       |
   *               +-------+
   *
   *        +--+   +---+    &lt;-- 가로 길이의 절반
   *        +----------+    &lt;-- 중심간의 거리
   *
   * 각 상자의 길이의 절반의 합이 중심간의 거리보다 작을 때에만 충돌이다.
   * 이 때 충돌한 깊이는 각 길이의 절반의 합과 중심간의 거리의 차로 구해진다.
   *
   * @param {GameObject} box - 이 객체와 충돌한 다른 객체
   * @returns {Manifold}
   */
  resolveBoxCollision(box) {
    const distance = box
      .getColliderWorldPosition()
      .minus(this.box.getColliderWorldPosition());

    // 충돌된 영역의 가로 길이
    const xOverlap =
      this.box.getWorldBoundary().x / 2 +
      box.getWorldBoundary().x / 2 -
      Math.abs(distance.x);
    // 충돌된 영역의 세로 길이
    const yOverlap =
      this.box.getWorldBoundary().y / 2 +
      box.getWorldBoundary().y / 2 -
      Math.abs(distance.y);

    if (xOverlap &lt; 0 || yOverlap &lt; 0) {
      return;
    }

    let normal = new Vector(0, -1);
    let penetrationDepth = 0;

    // 가로 길이가 세로 길이보다 크다면
    // 위->아래방향 또는
    // 아래->위방향으로 진행한 물체가 충돌한 것이다.
    if (xOverlap > yOverlap) {
      // obj이 other보다 아래에 있으면 위에서 아래로 충돌했다는 말이므로
      // 힘(반작용)은 위로 작용해야한다.
      // 그렇지 않으면 힘이 아래로 작용해야한다.
      if (distance.y &lt; 0) {
        normal = new Vector(0, -1);
      } else {
        normal = new Vector(0, 1);
      }
      penetrationDepth = yOverlap;
    } else {
      // 세로 길이가 가로 길이보다 크다는 말은
      // 왼쪽->오른쪽방향 또는
      // 오른쪽->왼쪽방향으로 진행한 물체가 충돌한 것이다.
      // obj이 other보다 왼쪽에 있으면
      // 힘(반작용)은 왼쪽으로 작용해야한다.
      // 반대의 경우 오른쪽으로 작용해야한다.
      if (distance.x &lt; 0) {
        normal = new Vector(-1, 0);
      } else {
        normal = new Vector(1, 0);
      }
      penetrationDepth = xOverlap;
    }

    return new Manifold(this.box, box, normal, penetrationDepth);
  }

  /**
   * 원이 상자와 충돌했을 때 충돌깊이와 반작용방향을 반환한다.
   *
   * @param {GameObject} circle - 이 객체와 충돌한 다른 객체
   * @returns {Manifold}
   */
  resolveCircleCollision(circle) {
    const rectCenter = this.box.getColliderWorldPosition();

    const distance = circle.getColliderWorldPosition().minus(rectCenter);

    const closest = new Vector(
      clamp(
        distance.x,
        -this.box.getWorldBoundary().x / 2,
        this.box.getWorldBoundary().x / 2
      ),
      clamp(
        distance.y,
        -this.box.getWorldBoundary().y / 2,
        this.box.getWorldBoundary().y / 2
      )
    );

    let inside = false;

    // 만약 원의 중심이 사각형의 안에 들어와 있다면...
    // closest는 항상 사각형 내로 clamp되어 있기 때문에
    // distance + rectCenter와 똑같아지게 된다.
    if (distance.isEquals(closest)) {
      inside = true;

      // 중심에서 어떤 축이 더 가까운지 찾는다.
      if (Math.abs(distance.x) &lt; Math.abs(distance.y)) {
        // y편차가 더 작다는 말은?

        // 사각형에서 원과 가장 가까운 점을 찾아야 하므로
        // 가장 가까운 사각형의 경계를 점으로 선택한다.
        if (closest.x > 0) {
          closest.x = this.box.getWorldBoundary().x / 2;
        } else {
          closest.x = -this.box.getWorldBoundary().x / 2;
        }
      } else {
        if (closest.y > 0) {
          closest.y = this.box.getWorldBoundary().y / 2;
        } else {
          closest.y = -this.box.getWorldBoundary().y / 2;
        }
      }
    }

    let penetrationDepth = 0;
    let normal = distance.minus(closest);
    const d = normal.squareLength();

    if (d > circle.getWorldBoundary() * circle.getWorldBoundary() &amp;&amp; !inside) {
      return;
    }

    if (inside) {
      normal = normal.multiply(-1).normalize();
      // 원이 사각형 안에 있다면 단순하게 충돌 깊이를 반지름 * 2로 설정한다.
      penetrationDepth = 2 * circle.getWorldBoundary();
    } else {
      normal = normal.multiply(1).normalize();
      // 원이 사각형 밖에 있다면 충돌 깊이를 반지름에서 충돌한 거리를 뺀 값으로 설정한다.
      penetrationDepth = circle.getWorldBoundary() - Math.sqrt(d);
    }

    return new Manifold(this.box, circle, normal, penetrationDepth);
  }
}

export default BoxCollisionResolver;
</code></pre>
</article>
<script src="static/highlight/langs/line-numbers.min.js"></script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
    function identifyAndScrollToLines() {
        document.querySelectorAll(".hljs-ln-numbers").forEach(function (el) {
            if (window.location.hash === ("#L" + el.dataset.lineNumber)) {
                el.parentElement.classList.add("selected");
                el.parentElement.scrollIntoView({behavior: "smooth", inline: "start"});
            }
        });
    }
    
    window.addEventListener("load", identifyAndScrollToLines);
    window.setTimeout(identifyAndScrollToLines, 10);
</script>
<aside class="content-aside">
    
    
        <div class="toc-tiny">
            <h2 class="page-title">Source: <span class="ancestors"></span>./src/engine/core/box-collision-resolver.js</h2>
        </div>
    
</aside>
        <footer>
            Generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a>
            using <a href="https://github.com/sleelin/classy-template">classy-template</a>
            
                <span class="creation-timestamp">2023-05-27T15:17:44.491Z</span>
            
        </footer>
    </main>
    <script>hljs.highlightAll();</script>
</body>

</html>
